---
date: 2021-03-04
title: "임베디드 제어 관점에서의 C언어 문법 정리"
categories: Embedded_Firmware
tags: jekyll
toc: true  
toc_sticky: true 
---

임베디드 제어 관점에서의 C언어 문법 정리
=============
이번 포스팅은 제가 지금까지 임베디드 펌웨어를 다루면서 C언어 문법 중 사소하지만 중요하다고 생각하는 내용을 정리하려합니다.

포스팅을 통해 정리하면서 막상 쓰지만 잘 인지하고 있지 못하거나 그냥 쓰는 것들 알고보니 햇갈리고 있었던 부분들을 알게된 계기가 되었습니다.

C언어의 기본부터 심화까지 다루어볼 것이고 저의 주관적인 관점이 많이 들어가 있음을 먼저 말씀드립니다.

# 1. C언어 기본
## 1.1 연산자
### 1.1.1 대입연산자 ( = )
* 연산자 **오른쪽** 에 있는 값을 연산자 **왼쪽** 에 있는 변수에 대입한다. **( <-- )**
```
오른쪽, 왼쪽을 햇갈리지 말기
나머지 연산자는 왼쪽에서 오른쪽으로 처리
```

### 1.1.2 증감연산자 ( ++ , -- )
* ++num : 전위증가. 선 증가 후 연산
* num++ : 후위증가. 선 연산 후 증가
* --num : 전위감소, 선 감소 후 연산
* num-- : 후위감소, 선 연산 후 감소
```
전위증가(감소)는 먼저 변수값을 증가(감소) 후 연산(함수 매개변수 대입 등) 수행.
후위증가(감소)는 먼저 연산(함수 매개변수 대입 등) 후 변수값을 증가(감소) 수행.
소괄호 '(' ')' 의 영향을 받지 않음!
```

### 1.1.3 관계연산자 ( < , > , == , != , <= , >= )와 논리 연산자( && , || , ! )
```
관계연산자가 논리연산자보다 먼저 수행함!
0이 아닌 모든 값은 참(ture)
```

### 1.1.4 비트연산자 ( & , | , ^ , ~ , << , >> )
```
비트연산에 사용되는 변수는 변화 없음. 결과만 반환함.
```
* ^ : 비트단위 XOR. 두 개의 비트가 서로 다른 경우에 1을 반환.
* num<<2 : num을 2 칸 왼쪽(<<) 이동 결과 반환
* num>>2 : num을 2 칸 오른쪽(>>) 이동 결과 반환
```
햇갈리지 말것.
```

### 1.1.5 연산자의 우선순위와 결합방향
```
결합방향? 
=> 우선순위가 동일한 두 연산자가 하나의 수식에 존재하는 경우, 
   어떠한 순서( <-- or --> )대로 연산하는지를 결정한 것
```
* 연산자의 우선순위와 결합방향 표



## 1.2 데이터 표현 방식
### 1.2.1 2진수, 8진수, 16진수 데이터 표현
* int num1 = 15;  //10진수의 표현
* int num2 = 0b00001111;  //0b로 시작하면 2진수로 인식
* int num3 = 0x0F;  //0x로 시작하면 16진수로 인식
* int num4 = 017;  //0으로 시작하면 8진수로 인식
```
솔직히 8진수는 쓸일이 없을 거 같다
```

### 1.2.2 정수의 부호 표현방식
* (MSB) 0 0 0 0 0 1 0 1 (LSB) //+5
* (MSB) 1 1 1 1 1 0 1 1 (LSB) //-5
```
가장 최상위 비트(MSB)의 값이 0 이면 양수, 1 이면 음수
하지만, 음의 정수를 표현할 때는 2의 보수를 취함.
음의 정수를 비트 연산 시, 참고할 것.
```

### 1.2.3 실수의 오차
* 0.1을 100번 더한 결과 : 10.000002
```
실수에 대한 연산 시, 실수 자체가 가지고 있는 '부동 소수점 오차'로 인한 
출력결과의 오차 발생.
=> 절대로! 실수와 정수의 비교 연산 시,
   1. 실수를 정수로 Casting 한 후 비교 연산
      (소수점자리까지 비교하고 싶을 경우, 해당 소수점자리만큼 10을 곱한 후 정수로 Casting 해서 비교할 것.)
   2. 실수와 비교하려는 수의 차이를 구하고 math.h 헤드파일의 fabsf 함수를 사용하여 절댓값으로 만들고
      머신 엡실론(machine epsilon)과 비교하는 방법을 사용할 것.
```

## 1.3 자료형
### 1.3.1 자료형 종류와 데이터의 표현 범위
* char : 1바이트
* short : 2바이트
* int : 2바이트
* long : 4바이트
* long long : 8바이트
* float : 4바이트
* double : 8바이트
* long double : 8바이트 이상
```
사용하는 컴파일러에 따라 미세하게 다른 점이 있는 것으로 알고 있다.
(C언어의 표준을 정하는 ANSI에서 자료형 별 크기를 정확히 제한하고 있지 않다.)
특히, short와 int는 최소 2바이트이되, int는 short와 크기가 같거나 더 커야한다.
```
### 1.3.2 Sizeof 연산자
* int sz1 = sizeof(int); // 자료형 int의 크기를 Byte 단위로 반환.
```
메모리 공간에서 실제로 소모하는 메모리의 크기를 바이트 단위로 반환해준다.
자신이 사용하는 컴파일러의 자료형 별 바이트 크기를 확인할 수 있다.
절대로 함수가 아니다. 연산자이다.
```

